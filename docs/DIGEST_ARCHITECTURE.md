# Новая архитектура дайджестов

Документ описывает слой дайджестов, внедрённый в рамках новой модульной архитектуры. Цель — отделить бизнес-логику формирования дайджестов от Telegram-бота и подготовить основу для дальнейшего расширения.

## Обзор уровней

Архитектура строится вокруг четырёх уровней, соединённых через простую DI-обвязку:

| Уровень | Назначение | Ключевые компоненты |
|---------|------------|---------------------|
| **Domain** | Хранит описание типов дайджестов и их промпты. | [`internal/domain/digest.go`](../internal/domain/digest.go), [`internal/domain/prompts.go`](../internal/domain/prompts.go) |
| **Services** | Инкапсулирует бизнес-логику генерации дайджеста и взаимодействие с LLM. | [`internal/services/digest.go`](../internal/services/digest.go), [`internal/services/ai_adapter.go`](../internal/services/ai_adapter.go) |
| **Handlers** | Реализует обработчики Telegram-команд, оборачивая сервисы. | [`internal/handlers/digest.go`](../internal/handlers/digest.go) |
| **Integration** | Собирает все зависимости и регистрирует команды в существующем боте. | [`internal/bot/digest_integration.go`](../internal/bot/digest_integration.go), [`internal/container/container.go`](../internal/container/container.go) |

## Жизненный цикл команды

1. **Пользователь** вызывает `/crypto`, `/tech`, `/business` и т.д.
2. **`DigestHandler`** получает событие, читает активную модель из рантайм-конфига (TODO в коде) и формирует `DigestRequest`.
3. **`DigestService`** валидирует тип дайджеста, накладывает таймаут и подставляет шаблон промпта из `domain`.
4. **`OpenAIAdapter`** упаковывает запрос в формат `go-openai`, применяет настройки (`MaxTokens`, `ServiceTier`, web-search) и отправляет вызов.
5. **Ответ** возвращается вверх по цепочке, после чего обработчик делит сообщение на части (если нужно) и отправляет в чат.

## DI-контейнер

- **Регистрация.** `DigestIntegration` создаёт контейнер (`internal/container.Container`), регистрирует `OpenAIAdapter`, обработчик ошибок и базовые настройки (таймаут).
- **Сборка.** `ServiceBuilder` последовательно строит `DigestService` и `DigestHandler`, автоматически резолвя зависимости.
- **Замена хендлеров.** После сборки `DigestIntegration.ReplaceDigestHandlers` регистрирует новые команды в `telebot.Bot`, перекрывая старые имплементации.

Такой подход упрощает переиспользование сервисов (например, для cron-задач) и подготовлен к дальнейшему расширению: контейнер может собирать другие обработчики по тому же принципу.

## Добавление нового дайджеста

1. **Domain.** Добавьте новый `DigestConfig` и промпт в `internal/domain`.
2. **Маршрутизация.** Вызовите `GetDigestConfigs()` — DI-контур зарегистрирует команду автоматически.
3. **Кастомизация.** При необходимости расширьте `DigestService.applyTemplate` или внедрите отдельный сервис/адаптер через контейнер.

## Точки для доработки

- **Рантайм-конфиг.** `handlers.DigestHandler` и `services.OpenAIAdapter` пока используют заглушки `getCurrentModel()` и `getRuntimeConfig()`. План — заменить их реальными сервисами конфигурации.
- **Шаблоны.** `DigestService.applyTemplate` применяет простую замену строк. Для сложных шаблонов можно интегрировать стандартный `text/template`.
- **Тесты.** `internal/services/digest_test.go` покрывает бизнес-логику; при добавлении новых веток следует расширять тесты на уровне сервиса.

## Связь с существующим ботом

`internal/bot/app.go` инициализирует `DigestIntegration` в `Bot.Start()`. Это позволяет постепенно мигрировать остальные команды на новую архитектуру, не трогая остальной код бота. Остальные обработчики пока работают по старой схеме, что обеспечивает обратную совместимость.
